import os
import sqlite3
from abc import ABC, abstractmethod
from typing import Any, Literal

from baza_danych_Exceptions import (
    AutoGeneratedRowIdConflictDodajPrzestrzenException,
    AutoGeneratedRowIdConflictFromAddException,
    ColumnIdNotFoundDodajPrzestrzenException, ColumnIdNotFoundFromAddException,
    ColumnNameNotFoundDodajPrzestrzenException,
    ColumnNameNotFoundFromAddException, ColumnNotFoundUsunException,
    ConnectionClosedFromSaveException, DatabaseFileFromSaveException,
    DatabaseIntegrityFromSaveException, DatabaseOpenException,
    DatabaseOperationalException, DatabaseOperationalFromSaveException,
    DatabasePermissionFromSaveException, DuplicateColumnKeyException,
    DuplicateRowKeyException, EmptyDatabaseException,
    EmptyDatabaseFromSaveException, FileNotFoundException,
    InvalidAdditionElementNoneDodajPrzestrzenException,
    InvalidAdditionElementNoneFromAddException,
    InvalidColumnFormatFromSaveException, InvalidColumnIndexException,
    InvalidColumnKeyException, InvalidColumnKeyFromSaveException,
    InvalidColumnNameCharactersException, InvalidColumnNameException,
    InvalidColumnTupleStructureDodajPrzestrzenException,
    InvalidColumnTupleStructureFromAddException,
    InvalidColumnTupleStructureUsunException,
    InvalidColumnTypeDodajPrzestrzenException,
    InvalidColumnTypeFromAddException, InvalidColumnTypeUsunException,
    InvalidColumnValuesException, InvalidColumnValuesFromSaveException,
    InvalidDatabaseTypeException, InvalidDatabaseTypeFromSaveException,
    InvalidDatabaseTypeUsunException, InvalidElementKeyUsunException,
    InvalidRemovalNameTypeUsunException, InvalidRemovalTypeUsunException,
    InvalidRowContainerTypeDodajPrzestrzenException,
    InvalidRowContainerTypeFromAddException,
    InvalidRowIdInColumnDodajPrzestrzenException,
    InvalidRowIdInColumnFromAddException, InvalidRowKeyException,
    InvalidRowKeyFromSaveException, InvalidRowKeyTypeDodajPrzestrzenException,
    InvalidRowKeyTypeFromAddException,
    MissingRowIdWhenAutoDisabledDodajPrzestrzenException,
    MissingRowIdWhenAutoDisabledFromAddException,
    MissingRowNameDodajPrzestrzenException, MissingRowNameFromAddException,
    NoDatabaseProvidedDodajPrzestrzenException,
    NoDatabaseProvidedFromAddException, NoDatabaseProvidedUsunException,
    NoneValueException, NoneValueFromSaveException, RowNotFoundUsunException,
    UnsupportedValueTypeException, UnsupportedValueTypeFromSaveException)


class __baza_danych__(ABC):
    @abstractmethod
    def BazadanychSprawdzOtworz(func):
        pass # zrobione

    @abstractmethod
    def BazadanychSprawdzZapisz(func):
        pass # zrobione

    @abstractmethod
    def BazadanychsprawdzDodajElement(func):
        pass

    @abstractmethod
    def BazadanychsprawdzDodajPrzesten(func):
        pass
    
    @abstractmethod
    def BazadanychsprawdzUsun(func):
        pass
    
    @abstractmethod
    def BazadanychsprawdzEdytuj(func):
        pass
    
    @abstractmethod
    def BazadanychsprawdzZnajdz(func):
        pass
    
    def __init__(self, nazwa: str):
        self.nazwa = nazwa
        self.bazadanych: dict[tuple[int, str], dict[int, Any]]

    @abstractmethod
    def otworz(self, nazwa: str, czy_nowa: bool) -> None:
        pass

    @abstractmethod
    def dodaj_element(self, kolumna: int | str, wiersz: int | str,
                      autoWiersz: bool, wartosc: Any, bazadanych = None):
        pass

    @abstractmethod
    def dodaj_przesten(self, coDodac: Literal["kolumna", "wiersz"], nazwa: str):
        pass

    @abstractmethod
    def usun(self, coUsun: Literal["kolumna", "wiersz", "element"]):
        pass

    @abstractmethod
    def edytuj(self, kolumna: int | str, wiersz: int | str, nowyElement: int | str):
        pass

    @abstractmethod
    def znajdz(self, element: int | str, coZnajdz: Literal["kolumna", "wiersz", "element"], zwracaBool = False):
        pass 


class BazadanychsprawdzDodajPrzestenException(Exception):
    pass

# wyjątki sprawdzDodajPrzesten

class BazadanychsprawdzUsunException(Exception):
    pass

# pozostałe dodać

class Bazadanych(__baza_danych__):

    def BazadanychSprawdzOtworz(func):
        def wrapper(self, *args, **kwargs):
            try:
                if not getattr(self, "_tworzymy_nowy", False):
                    if not os.path.isfile(self.nazwa):
                        raise FileNotFoundException(f"Plik bazy '{self.nazwa}' nie istnieje")

                result = func(self, *args, **kwargs)

                if not isinstance(self.bazadanych, dict):
                    raise InvalidDatabaseTypeException(type(self.bazadanych))

                if len(self.bazadanych) == 0 and not getattr(self, "_tworzymy_nowy", False):
                    raise EmptyDatabaseException()

                klucze_kolumn = set()
                niedozwolone_znaki = set(" ;'\"\\/%$#@!&*()+=[]{}|<>?")

                for klucz, wartosci in self.bazadanych.items():
                    if not (isinstance(klucz, tuple) and len(klucz) == 2):
                        raise InvalidColumnKeyException(klucz)

                    idx, nazwa = klucz

                    if not isinstance(idx, int):
                        raise InvalidColumnIndexException(idx)

                    if not isinstance(nazwa, str):
                        raise InvalidColumnNameException(nazwa)

                    if klucz in klucze_kolumn:
                        raise DuplicateColumnKeyException(klucz)
                    klucze_kolumn.add(klucz)

                    if any(c in niedozwolone_znaki for c in nazwa):
                        raise InvalidColumnNameCharactersException(nazwa)

                    if not isinstance(wartosci, dict):
                        raise InvalidColumnValuesException(klucz)

                    wiersze_klucze = set()

                    for wiersz, wartosc in wartosci.items():
                        if not isinstance(wiersz, (int, str)):
                            raise InvalidRowKeyException(wiersz)

                        if wiersz in wiersze_klucze:
                            raise DuplicateRowKeyException(wiersz, klucz)
                        wiersze_klucze.add(wiersz)

                        if wartosc is None:
                            raise NoneValueException(klucz, wiersz)

                        if not isinstance(wartosc, (int, float, str, bool)):
                            raise UnsupportedValueTypeException(type(wartosc), klucz, wiersz)

                return result

            except FileNotFoundException as e:
                raise e

            except sqlite3.OperationalError as e:
                raise DatabaseOperationalException(str(e))

            except Exception as e:
                raise DatabaseOpenException(f"Błąd podczas otwierania bazy: {e}")

        return wrapper


    def BazadanychSprawdzZapisz(func):
        def wrapper(self, *args, **kwargs):
            try:
                if self.conn is None:
                    raise ConnectionClosedFromSaveException()

                if not isinstance(self.bazadanych, dict):
                    raise InvalidDatabaseTypeFromSaveException(type(self.bazadanych))

                if len(self.bazadanych) == 0:
                    raise EmptyDatabaseFromSaveException()

                for klucz, wartosci in self.bazadanych.items():
                    if not (isinstance(klucz, tuple) and len(klucz) == 2):
                        raise InvalidColumnKeyFromSaveException(klucz)

                    idx, nazwa = klucz
                    if not isinstance(idx, int) or not isinstance(nazwa, str):
                        raise InvalidColumnFormatFromSaveException(klucz)

                    if not isinstance(wartosci, dict):
                        raise InvalidColumnValuesFromSaveException(klucz)

                    for wiersz, wartosc in wartosci.items():
                        if not isinstance(wiersz, (int, str)):
                            raise InvalidRowKeyFromSaveException(wiersz)

                        if wartosc is None:
                            raise NoneValueFromSaveException(klucz, wiersz)

                        if not isinstance(wartosc, (int, float, str, bool)):
                            raise UnsupportedValueTypeFromSaveException(type(wartosc), klucz, wiersz)

                return func(self, *args, **kwargs)

            except sqlite3.IntegrityError as e:
                raise DatabaseIntegrityFromSaveException(str(e))

            except sqlite3.OperationalError as e:
                raise DatabaseOperationalFromSaveException(str(e))

            except sqlite3.DatabaseError as e:
                raise DatabaseFileFromSaveException(str(e))

            except PermissionError as e:
                raise DatabasePermissionFromSaveException(str(e))

            except Exception as e:
                raise Exception(f"Błąd podczas zapisywania bazy: {e}")

        return wrapper

    def BazadanychsprawdzDodajElement(func):
        def wrapper(self, kolumna, wiersz, autoWiersz, wartosc, bazadanych):
            if bazadanych is None:
                assert NoDatabaseProvidedFromAddException("bazadanych is None")

            if isinstance(kolumna, int):
                kolumna_key = None

                for key in bazadanych.keys():

                    if not (isinstance(key, tuple) and len(key) == 2 and isinstance(key[0], int) and isinstance(key[1], str)):
                        assert InvalidColumnTupleStructureFromAddException(str(key))

                    if key[0] == kolumna:
                        kolumna_key = key
                        break

                if kolumna_key is None:
                    assert ColumnIdNotFoundFromAddException(kolumna)

            elif isinstance(kolumna, str):
                kolumna_key = None

                for key in bazadanych.keys():

                    if not (isinstance(key, tuple) and len(key) == 2 and isinstance(key[0], int) and isinstance(key[1], str)):
                        assert InvalidColumnTupleStructureFromAddException(str(key))

                    if key[1] == kolumna:
                        kolumna_key = key
                        break

                if kolumna_key is None:
                    assert ColumnNameNotFoundFromAddException(kolumna)

            else:
                assert InvalidColumnTypeFromAddException(type(kolumna))

            wiersze = bazadanych.get(kolumna_key)
            if not isinstance(wiersze, dict):
                assert InvalidRowContainerTypeFromAddException(type(wiersze))

            if autoWiersz:

                if len(wiersze) == 0:
                    wiersz = 0

                else:
                    wiersz = max(wiersze.keys()) + 1

                if wiersz in wiersze:
                    assert AutoGeneratedRowIdConflictFromAddException(wiersz)
            else:

                if wiersz is None:
                    assert MissingRowIdWhenAutoDisabledFromAddException()

                if isinstance(wiersz, int):
                    if wiersz not in wiersze:
                        assert InvalidRowIdInColumnFromAddException(wiersz, kolumna_key)

                elif isinstance(wiersz, str):
                    znaleziono = False

                    for v in wiersze.values():
                        if v == wiersz:
                            znaleziono = True
                            break

                    if not znaleziono:
                        assert MissingRowNameFromAddException(wiersz)
                else:
                    assert InvalidRowKeyTypeFromAddException(type(wiersz))

            if wartosc is None:
                assert InvalidAdditionElementNoneFromAddException(wartosc)

            return func(self, kolumna_key, wiersz, autoWiersz, wartosc, bazadanych)

        return wrapper

    def BazadanychsprawdzDodajPrzesten(func):
        def wrapper(self, coDodac, nazwa):
            if not hasattr(self, "bazadanych") or self.bazadanych is None:
                raise NoDatabaseProvidedDodajPrzestrzenException("self.bazadanych = None")

            if not isinstance(self.bazadanych, dict):
                raise InvalidRowContainerTypeDodajPrzestrzenException(type(self.bazadanych))

            if coDodac not in ("kolumna", "wiersz"):
                raise InvalidAdditionElementNoneDodajPrzestrzenException(f"{coDodac}")

            if not isinstance(nazwa, str):
                raise InvalidRowKeyTypeDodajPrzestrzenException(type(nazwa))

            istniejące_wiersze = set()

            kolumna_znaleziona = False
            kolumna_id_znaleziona = False
            wiersz_nazwa_znaleziona = False

            for klucz, wiersze in self.bazadanych.items():
                if not (isinstance(klucz, tuple) and len(klucz) == 2):
                    raise InvalidColumnTupleStructureDodajPrzestrzenException(klucz)

                idx, kol_nazwa = klucz
                if not isinstance(idx, int):
                    raise InvalidColumnTypeDodajPrzestrzenException(type(idx))

                if not isinstance(kol_nazwa, str):
                    raise InvalidColumnTypeDodajPrzestrzenException(type(kol_nazwa))

                if not isinstance(wiersze, dict):
                    raise InvalidRowContainerTypeDodajPrzestrzenException(type(wiersze))

                if coDodac == "kolumna":
                    if kol_nazwa == nazwa:
                        kolumna_znaleziona = True
                    if idx == nazwa:
                        kolumna_id_znaleziona = True

                for wiersz_id, wartosc in wiersze.items():
                    if not isinstance(wiersz_id, (int, str)):
                        raise InvalidRowKeyTypeDodajPrzestrzenException(type(wiersz_id))

                    if wartosc is None:
                        raise InvalidAdditionElementNoneDodajPrzestrzenException(f"Wartość None w wierszu {wiersz_id}")

                    if coDodac == "wiersz":
                        if wiersz_id in istniejące_wiersze:
                            raise AutoGeneratedRowIdConflictDodajPrzestrzenException(wiersz_id)
                        istniejące_wiersze.add(wiersz_id)

                        if isinstance(nazwa, str) and wiersz_id == nazwa:
                            wiersz_nazwa_znaleziona = True

            if coDodac == "kolumna":
                if isinstance(nazwa, int) and not kolumna_id_znaleziona:
                    raise ColumnIdNotFoundDodajPrzestrzenException(nazwa)
                if isinstance(nazwa, str) and not kolumna_znaleziona:
                    raise ColumnNameNotFoundDodajPrzestrzenException(nazwa)

            if coDodac == "wiersz" and not wiersz_nazwa_znaleziona:
                raise MissingRowNameDodajPrzestrzenException(nazwa)

            if coDodac == "wiersz":
                if not getattr(self, "autoWiersz", True) and (nazwa is None or nazwa == ""):
                    raise MissingRowIdWhenAutoDisabledDodajPrzestrzenException()

            for klucz, wiersze in self.bazadanych.items():
                int_keys = [k for k in wiersze.keys() if isinstance(k, int)]
                if int_keys:
                    int_keys_sorted = sorted(int_keys)
                    expected = list(range(len(int_keys_sorted)))
                    if int_keys_sorted != expected:
                        raise InvalidRowIdInColumnDodajPrzestrzenException(
                            f"Kolejność ID w kolumnie {klucz} jest niepoprawna. "
                            f"Oczekiwano {expected}, otrzymano {int_keys_sorted}"
                        )

            return func(self, coDodac, nazwa)

        return wrapper

    
    def BazadanychsprawdzUsun(func):
        def wrapper(self, coUsun: Literal["kolumna", "wiersz", "element"], nazwa):
            if not hasattr(self, "bazadanych") or self.bazadanych is None:
                raise NoDatabaseProvidedUsunException("self.bazadanych = None")

            if not isinstance(self.bazadanych, dict):
                raise InvalidDatabaseTypeUsunException(type(self.bazadanych))

            if coUsun not in ("kolumna", "wiersz", "element"):
                raise InvalidRemovalTypeUsunException(f"Nieprawidłowy typ do usunięcia: {coUsun}")

            if not isinstance(nazwa, (str, int, tuple)):
                raise InvalidRemovalNameTypeUsunException(type(nazwa))

            if coUsun == "kolumna":
                znaleziono = False
                for klucz in self.bazadanych.keys():
                    if not (isinstance(klucz, tuple) and len(klucz) == 2):
                        raise InvalidColumnTupleStructureUsunException(klucz)

                    idx, kol_nazwa = klucz
                    if not (isinstance(idx, int) and isinstance(kol_nazwa, str)):
                        raise InvalidColumnTypeUsunException(klucz)

                    if nazwa == kol_nazwa or nazwa == idx:
                        znaleziono = True
                        break
                if not znaleziono:
                    raise ColumnNotFoundUsunException(nazwa)

            elif coUsun == "wiersz":
                znaleziono = False
                for wiersze in self.bazadanych.values():
                    if nazwa in wiersze:
                        znaleziono = True
                        break
                if not znaleziono:
                    raise RowNotFoundUsunException(nazwa)

            elif coUsun == "element":
                if not (isinstance(nazwa, tuple) and len(nazwa) == 2):
                    raise InvalidElementKeyUsunException(nazwa)

                kolumna, wiersz = nazwa

                kolumna_znaleziona = any(
                    isinstance(k, tuple) and len(k) == 2 and (k[0] == kolumna or k[1] == kolumna)
                    for k in self.bazadanych
                )
                if not kolumna_znaleziona:
                    raise ColumnNotFoundUsunException(kolumna)

                wiersz_znaleziony = False
                for klucz, wiersze in self.bazadanych.items():
                    if klucz[0] == kolumna or klucz[1] == kolumna:
                        if wiersz in wiersze:
                            wiersz_znaleziony = True
                            break
                if not wiersz_znaleziony:
                    raise RowNotFoundUsunException(wiersz)

            return func(self, coUsun, nazwa)

        return wrapper

    
    def BazadanychsprawdzEdytuj(func):
        def wrapper(self, kolumna, wiersz, nowyElement):
            0 # sprawdza czy git
            return func(self, kolumna, wiersz, nowyElement)
        return wrapper
    
    def BazadanychsprawdzZnajdz(func):
        def wrapper(self, ):
            0 # sprawdza czy git
            return func(self, )
        return wrapper

    def __init__(self, nazwa: str):
        super().__init__(nazwa)
        self.nazwa = nazwa
        self.bazadanych: dict[tuple[int, str], dict[int, Any]]

        self.bazadanych = {(0, "nazwaKolumna"): {0: "00Wartość", 1: "01Wartość"}, (1, "name1Kolumna1"): {0: "10Wartość", 1: "11Wartość"}}

    @BazadanychSprawdzOtworz
    def otworz(self, nazwa, czy_nowa=False):
        self.nazwa = nazwa
        self._tworzymy_nowy = czy_nowa

        if czy_nowa:
            self.bazadanych = {}
        else:
            conn = sqlite3.connect(nazwa)
            cursor = conn.cursor()
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
            tabele = [row[0] for row in cursor.fetchall()]

            self.bazadanych = {}
            col_id_counter = 0

            for tabela in tabele:
                cursor.execute(f"PRAGMA table_info('{tabela}')")
                kolumny_info = cursor.fetchall()

                for kolumna_info in kolumny_info:
                    _, nazwa_kolumny, _, _, _, _ = kolumna_info
                    klucz = (col_id_counter, nazwa_kolumny)
                    col_id_counter += 1

                    cursor.execute(f"SELECT rowid, \"{nazwa_kolumny}\" FROM '{tabela}'")
                    wiersze = cursor.fetchall()

                    wiersze_slownik = {}
                    for rowid, wartosc in wiersze:
                        wiersze_slownik[rowid] = wartosc

                    self.bazadanych[klucz] = wiersze_slownik

            conn.close()

        self._tworzymy_nowy = False

    @BazadanychSprawdzZapisz # ZROBIONE
    def zapisz(self):
        for (_, nazwa), wiersze in self.bazadanych.items():
            self.cursor.execute(
                f"""CREATE TABLE IF NOT EXISTS [{nazwa}] (
                    wiersz TEXT PRIMARY KEY,
                    wartosc TEXT
                )"""
            )

            for wiersz, wartosc in wiersze.items():
                self.cursor.execute(
                    f"""INSERT INTO [{nazwa}] (wiersz, wartosc)
                        VALUES (?, ?)
                        ON CONFLICT(wiersz) DO UPDATE SET wartosc=excluded.wartosc""",
                    (str(wiersz), str(wartosc))
                )

        self.conn.commit()


    @BazadanychsprawdzDodajElement
    def dodaj_element(self, kolumna, wiersz, autoWiersz, wartosc, bazadanych):
        self.bazadanych # nie zrobione

    @BazadanychsprawdzDodajPrzesten
    def dodaj_przesten(self, coDodac: Literal["kolumna", "wiersz"], nazwa: str):
        match coDodac:
            case "kolumna":
                nowy_id = max((k[0] for k in self.bazadanych), default=-1) + 1
                nowy_klucz = (nowy_id, nazwa)
                self.bazadanych[nowy_klucz] = {}

            case "wiersz":
                if getattr(self, "autoWiersz", True):
                    wszystkie_wiersze = set()
                    for wiersze in self.bazadanych.values():
                        wszystkie_wiersze.update(k for k in wiersze.keys() if isinstance(k, int))
                    nowy_wiersz_id = max(wszystkie_wiersze, default=-1) + 1
                else:
                    nowy_wiersz_id = nazwa

                for wiersze in self.bazadanych.values():
                    wiersze[nowy_wiersz_id] = None

    @BazadanychsprawdzUsun
    def usun(self, coUsun: Literal["kolumna", "wiersz", "element"], nazwa):
        if coUsun == "kolumna":
            klucze_do_usuniecia = [k for k in self.bazadanych if k[0] == nazwa or k[1] == nazwa]
            for k in klucze_do_usuniecia:
                del self.bazadanych[k]

        elif coUsun == "wiersz":
            for wiersze in self.bazadanych.values():
                if nazwa in wiersze:
                    del wiersze[nazwa]

        elif coUsun == "element":
            kolumna, wiersz = nazwa
            for klucz, wiersze in self.bazadanych.items():
                if klucz[0] == kolumna or klucz[1] == kolumna:
                    if wiersz in wiersze:
                        del wiersze[wiersz]


    @BazadanychsprawdzEdytuj
    def edytuj(self, kolumna, wiersz, nowyElement): # narazie zrobić na słowniku
        0 # edytuje konkretny element

    @BazadanychsprawdzZnajdz
    def znajdz(self, element, coZnajdz: Literal["kolumna", "wiersz", "element"], zwracaBool = False):
        0 # przeszukuje coZnajdz
        match coZnajdz:
            case "kolumna":
                0

            case "wiersz":
                0

            case "element":
                0

            case _:
                assert invalidElementFindIncoZnajdzException(coZnajdz)